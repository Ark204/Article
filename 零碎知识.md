# 零碎小知识
## 继承类型转换
**子类转父类**
对象：可以隐式向上转换，转换后**只呈现**<font color=red>**基类**</font>特性
引用/指针：可以隐式向上转换，转换后**可呈现**<font color=red>**子类**</font>特性
**父类转子类**
对象：不能向下转换
引用/指针：只能**显示**向下转换，但可能(使用子类特性时)带来不安全操作(<font color=red>允许但不安全</font>)

## 纯虚函数默认实现
**声明**：virtual int Fun()=0;
**提供默认实现**：int Base::Fun(){return m_i;}
**子类使用默认实现**：int Child::Fun(){return Base::Fun();}

## 引用与指针
### 指针
**声明**：int* ptrInt;//声明时可以不初始化
**赋值**：通常需要**“&”**取地址
ptrInt = <font color=red>&</font>i;//将指针赋值为i地址
ptrInt = (int*)10;//可以强制给指针赋值(<font color=red>不安全</font>)
**操作**：通常需要<code>**\***</code>前往地址
*ptrInt=10;//通过指针修改
**传递**：浅拷贝(传递指针**值**)
### 引用
**声明**：int& refInt=i;//声明时<font color=red>必须初始化</font>
**赋值**：对引用赋值操作实际上调用了**引用所指物**的**拷贝赋值**函数(无法让引用指向其他对象)
<code>refInt = j;</code>调用引用所指的int的**拷贝赋值**
**操作**：直接操作
refInt=10;//通过引用修改
**传递**：在栈上开辟一个内存空间存放**实参地址**。函数中对形参的操作都将被处理为间接寻址：通过栈中存放的地址访问实参本身。因此在函数中对形参的任何操作都会影响到实参本身
**本质**：对象的一个别名，编译器会将引用以“引用名-引用对象的地址”形式添加到符号表中，因为符号表是不能更改的(形如**后置const**指针)，因此引用对象的地址也不能更改，自然而然的引用也不能更改指向了，并且需要在创建时初始化

## new\[\]与delete\[\]
使用new\[\]分配的指针<font color=red>切记</font>用delete\[\]来释放

### 定位new
使用传递给他的地址使用内存(<font color=red>不管</font>该地址是否被分配使用),并将其强制转为void\*
例：
```C++
char buffer[512];//静态存储/自动存储
double *p=new (buffer/*可在此处+-地址偏移*/) double[6];//使用buffer内存
```
<font color=red>注意</font>：delete只能用于释放<font color=red>堆内存</font>
<code>delete[] p;</code>该代码合法，但<font color=red>危险</font>——运行时将出错(企图释放非堆内存)
**正确释放**：
1. 用定位new返回的指针**显式**调用相应**析构**函数
```C++
char buffer[512];
MClass* p=new(buffer) MClass();
p->~MClass();//显式调用析构释放
```
2. 定制delete

## 头文件
### <font color=red>不要</font>在头文件对**成员**及**非inline函数**定义
若包含函数定义，则当两个cpp文件包含该头文件时，将会生成同一个函数的两个定义
### <font color=red>不要</font>在头文件使用using编译指令
会掩盖要让哪些名称可用

## 32与64位下不同类型
|类型|32|64|
|:----:|:----:|:----:|
|指针|4位|8位
|long|4位|8位
|unsigned long|4位|8位
